# banking-tdd

This is a Test-Driven Development (TDD) practice project that walks you through the exercise of building a simple banking service, using TDD best practices.


## Exercise #1 - Setup TDD Project

* Let's add our first test case. Use `src/test/java` to place a new test class, e.g. `example.banking.services.BankingServiceTest`. Notice, that the test class doesn't compile, because few components do not resolve, e.g. `@Test` and `Assert`.
* Let's add JUnit 4 libraries to Maven dependencies (e.g. `artifactId=junit`,`groupId=junit`,`version=4.12`). Don't forget to update Maven project (e.g. `ALT-F5`). Organize imports in `BankingServiceTest` class (e.g. `CTRL+SHIFT+O`).


## Exercise #2 - First Scenario

* Your boss wants you to develop an API for banking (with little to no guidance). The API should include ability to transfer funds from account A to account B. Take a stab at developing a super-flexible API, based on little we know about the requirements.
* Scratch that. Let's write a test as if we were the user of this API. Note that `testTransfer` does not compile yet.
* QuickFix on `BankingService`. Create interface in `src/main/java` called `example.banking.services.BankingService`.
* QuickFix on `SimpleBankingService`. Create the implementation class, also in `src/main`java`, e.g. `example.banking.services.SimpleBankingService`.
* Extract local variables, instead of the hard-coded values in `transfer(1,2,1000.0)` method, e.g. `int fromAccountId = 1`, `int toAccountId = 2` and `double amount = 1000.0` and update the method, e.g. `transfer(fromAccountId, toAccountId, amount)`.
* QuickFix on `teller.transfer(...)` and create new method in `BankingService` interface and corresponding `SimpleBankingService`.
* QuickFix on `SimpleBankingService` class and add unimplemented methods, e.g. `SimpleBankingService.transfer(...)`.
* `testTransfer` compiles, passes, but not implemented.

## Exercise #3 - Structuring Tests
* What tests do we write next?
* How many tests do we need to write before we are sure our code works?
* What is a good test structure?
* Good test should have the following structure: (a) Assemble - test setup, (b) Test Fixture - setup test data, (c) Act - call business logic, (d) Verify - assert the results are what we expect, (e) Cleanup - test cleanup.
* Update `testTransfer` accordingly to include good test structure. Test compiles, test passes, not implemented yet.
* Think of Account class that will hold account details (id and balance). Update the test. Test will not compile.
* Add support for dealing with Account entities, e.g. `example.banking.dao.Accountdao`, `example.banking.dao.InMemoryAccountDao` and `example.banking.domain.Account`. Test will not compile yet.
* QuickFix on `getId()` and `getBalance()` in test class. Add unimplemented methods. Test will compile, test throws NullPointerException (error).
* Add implementation details for `InMemoryAccountDao`, e.g. `java.util.Map<Integer,Account>`. Update Account constructors. Test will now compile and generate no errors. Test will, however, fail due on verification step.

## Exercise #4 - Changing Requirements
* Your boss walks up again. Progress looks awesome, but we would like to track of the account owners, by their name. Also, account id properties will be auto-generated by the data layer.
* Update `AccountDao` interface and `InMemoryAccountDao` implementation to reflect new API change. Update `Account` to reflect new property.
* Now, looking at `Account` entity, we should probably revise `id` account property to indicate a database primary key, which is null if the entity is not in the database yet. Update `Account` code to reflect that. Add other override methods from `java.lang.Object`, e.g. `hashCode(..)`, `equals(..)` and `toString()`.
* We just thought of few test cases. Add test cases to the test class, e.g. `testAccountIdIsNullIfNotInDatabase()`, `testInsufficientFunds()` and `testAccountNotFoundInGet()` and mark them not implemented.
* Update `AccountDao` to include update account feature. Finish implementation of the `SimpleBankingService`. Test compiles. Test has an unexpected error, a `NullPointerException` bug. 

## Exercise #5 - Finding a Bug
* Why are we getting a `NullPointerException`? What happened? Is that a bug?
* It seems a new `AccountDao` instance is created every time we run `transfer(...)` method.
* Fix the bug.
* Suggestion 1: Inject AccountDao entity into `transfer(...)` method.
* Suggestion 2: Make database Map static in `InMemoryDao`.
* Suggestion 3: Instantiate `AccountDao` instance in service. Add `getDao()` to `SimpleBankingService` implementation.
* Suggestion 4: Use singleton for `AccountDao` instance.
* Suggestion 5: Use configuration service, e.g. `example.banking.services.ConfigurationService`. Test compiles and passes.

## Exercise #6 - Test Ordering
* Let's implement other test, e.g. `testAccountNotFoundInGet()`.
* Side discussion: Practically, we are testing `InMemoryAccountDao` implementation, which is not our intent. However, we know someone else will be writing DAO code soon, which will be different implementation than our `InMemoryAccountDao` testing implementation. This will make us think through the API. The team developing new DAO implementation will be able to take our unit tests, create integration tests and run them against their new DAO implementation. Thus, by writing these tests now, we are helping DAO developers define the contract.
* Tests results might depend on the execution order of the tests!
* Now, let's play with names of the test cases. Try changing names of the tests, e.g. `zzzz_testTrasnfer()` instead of `testTransfer()`. Run the tests! Were you able to reproduce test failure depending in which order tests were run? What happens if the test are run independently? How is that possible?
* What happens when you rerun test independently? Tests compile, test results are inconclusive and test fails/passes based on the test case method name.
* The order in which test cases will run is generally indeterministic. We could influence the ordering of tests.
* We need to think of a better strategy to approach tests. Let's create setup and teardown methods to execute before and after each test.
* We need to update ConfigurationService to provide `reset` method, and reset it every time a test is run. Tests compile and pass again.

## Exercise #7 - Dependency Injection
* Let's clean up our code, and make it more testable by using dependency injection.
* Inject `AccountDao` into constructor of `SimpleBankingService`.
* Let's clean up `InMemoryDao` as well, provide an alternative to inject the `Map<Integer,Account>` if needed into dao instance. Also, make `create(...)` synchronized.
* Let's implement the other test as well, e.g. `testAccountIdIsNullIfNotInDatabase()`. We might need to update our `Account` class to include default constructor.
* General formatting cleanup.

## Exercise #8 - Adding Exceptions
* It would be great to handle unusual (exceptional) situations. Let's add `AccountNotFoundException`, start with test cases first. Implement empty exception for now.
* We should add another test case for transferring money from an account that doesn't exist, and another for transferring money to account that doesn't exist, e.g. `testTransferMoneyFromNonExistingAccount()` and e.g. `testTransferMoneyToNonExistingAccount()`.
* Now, we might want to move `AccountNotFoundException` from services layer to data layer. What's involved in changing the API? Does our code compile? Did our tests break? Fix the issues.
* Let's add some more details to our `AccountNotFoundException`. Typical thing to do is instantiate an exception with some meaningful message. Try it out. What are some down sides of this approach?
* Better approach is to initialize exception with objects it needs to build a message, to enforce consistent message across the application. The result is a better API overall. Test compiles, test passes.
* Let's add support for additional exception, e.g. `InsufficientAccountBalance`. Update test cases first. Update data layer and service layer. Test compiles, test passes.
* Add test case with negative transfer amounts.
* Reject negative transfer amounts, e.g. throw IllegalArgumentException if amount is negative.

## Exercise #9 - Refactoring
* What's refactoring?
* Why should we refactor?
* When should we refactor?
* What's a code smell?
* Why refactoring works?
* What do you tell your manager?
* Problems with refactoring?
* When shouldn't you refactor?
* Let's refactor our code, and move logic for adding funds to account, and withdrawing funds from account to the `Account` entity, to fix the `FeatureEnvy` smell.
* Let's refactor our code again, use setters and getters for dealing with balances within `Account` entity.

## Exercise #10 - Mocking Objects with Mockito
* There are several mocking frameworks, e.g. `Mockito`, `EasyMock`, `JMockit`, etc. We will use `Mockito`.
* First, add support for Mockito libraries in `pom.xml`.
* Refactor `testTransfer` to use Mockito framework.
* Should the test fail if we forget to update data layer (database)? Mockito just ignores the call `AccountDao.save(...)` method to mock object. We should verify the interaction.
* Intentionally introduce the bug by not saving accounts in `SimpleBankingService.transfer(...)` method. Test compiles, test fails.
* Remove introduced bug. Test compiles, test passes.
* We could use helper Mockito methods to describe and verify interaction. Rewrite your test using `Mockito.times(x)` and `Mockito.any()`.
* We could also ensure mock object does not call certain methods. Rewrite your test using `Mockito.never()`, and other `Mockity.any*()` calls.
* Use static imports with `Mockito.*` and `Assert.*`.
* Find more details online in Mockito API.

## Exercise #11 - Mocking Objects with PowerMock
* PowerMock framework replaces class loader, to that we can instrument the class to mock static and final fields.
* Add back service locator `ConfigurationService` class with static methods and static fields.
* Add new test class, e.g. `BankingServiceWithPowerMock`. Create new test method, e.g. `testTransferWithPowerMock()` that copies old `testTransfer()`. Instantiate dao and service objects using `ConfigurationService` static methods. Test compiles, test fails with error.
* How do we mock objects that have static methods and final fields?
* Add support for PowerMock in `pom.xml`.
* Add runner, e.g. `@RunWith(PowerMockRunner.class)`.
* Prepare class with static methods for testing, e.g. `@PrepareForTesting(ConfigurationService.class)` either class-level or method-level.
* User `PowerMock.mockStatic(...)` to mock static methods.
* Feed real implementations for now, just to test if the PowerMock-ing works.
* Try removing any of two annotations, and observe the error messages.

## Exercise #12 - Testing with Spring Framework
* Often times we use Spring Framework to wire up our components in our project. Spring Framework has a great support for testing.
* Add support for Spring Framework in `pom.xml`.
